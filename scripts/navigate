#!/usr/bin/env python
import roslib; roslib.load_manifest('move_base_msgs')
import rospy
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from actionlib import SimpleActionClient, GoalStatus
from zbar_ros.msg import Marker
from ferns_ros.msg import ModelStatus



grafa = ["GRAFA1", "GRAFA2", "GRAFA3", "GRAFA4"]
hp = ["HP1", "HP2", "HP3", "HP4", "HP5", "HP6"]
loop = ["LOOP1", "LOOP2", "LOOP3", "LOOP4", "LOOP5", "LOOP6", "LOOP7", "LOOP8"]
sj = ["SJ1", "SJ2", "SJ3", "SJ4", "SJ5", "SJ6"]
tp = ["TP1", "TP2", "TP3", "TP4", "TP5"]
models = [maticna, hp, loop, sj, tp]
model_names = ["grafa", "hp", "loop", "sj", "tp"]

def callbackFerns(data):
    global lock
    lock = False

rospy.sleep(1.0)
lock = False

def activateFerns(data):
    activated = [model_names.index(i) for i in data if i in model_names]
    #print activated

    for i in range(len(models)):
        for model in models[i]:
            m = ModelStatus()
            m.model = model
            if i in activated:
                m.loaded = True
                m.active = True
            else:
                m.loaded = False
                m.active = False
            while True:
                if not lock:
                    break
            pub.publish(m)
            lock = True
            rospy.sleep(0.1)









import tf
from geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped
from copy import deepcopy

import sys

currentPosition = PoseWithCovarianceStamped()
qrCodes = set()
checkQR = True

points = {
    "1": ( 0.0, 0.0, 0.0, 0.0, -0.856375438851, 0.516353665362),
    "2": (-0.5, 0.0, 0.0, 0.0, 0.974899042305, -0.222647383352),
    "3": (-0.5, 0.3, 0.0, 0.0, 0.969342953931, 0.245711696231),
    "4": (-0.5, 1.0, 0.0, 0.0, 0.736656280611, 0.676267346718),
    "5": ( 0.0, 1.0, 0.0, 0.0, 0.512243727242, 0.858840127091),
    "6": ( 0.5, 1.0, 0.0, 0.0, 0.244970765239, 0.969530465833),
    "7": ( 0.5, 0.5, 0.0, 0.0, -0.259638318641, 0.965705930133),
    "8": ( 0.5, 0.0, 0.0, 0.0, -0.670306975309, 0.74208392979)
}

def moveOnMap(x, y):
    global currentPosition
    m = PoseStamped()
    m.pose.position.x = x    
    m.pose.position.x = y
    m.pose.orientation.x = currentPosition.pose.pose.orientation.x
    m.pose.orientation.y = currentPosition.pose.pose.orientation.y
    m.pose.orientation.z = currentPosition.pose.pose.orientation.z
    m.pose.orientation.w = currentPosition.pose.pose.orientation.w
    m.header.frame_id = "map"
    move(m)    

def move(poseStamped, target_frame="map"):
    global client
    goal = MoveBaseGoal()
    #print poseStamped.header.frame_id
    goal.target_pose.header.frame_id = target_frame
    goal.target_pose.header.stamp = rospy.get_rostime()

    goal.target_pose.pose.position.x = poseStamped.pose.position.x
    goal.target_pose.pose.position.y = poseStamped.pose.position.y
    goal.target_pose.pose.position.z = 0.0
    goal.target_pose.pose.orientation.x = poseStamped.pose.orientation.x
    goal.target_pose.pose.orientation.y = poseStamped.pose.orientation.y
    goal.target_pose.pose.orientation.z = poseStamped.pose.orientation.z
    goal.target_pose.pose.orientation.w = poseStamped.pose.orientation.w

    client.send_goal(goal)
    client.wait_for_result()
    return client.get_state() == GoalStatus.SUCCEEDED

def transformFromCameraToMap(origPoint, offset_x, offset_z, ox, oy, oz, ow):
    global listener
    p = deepcopy(origPoint)
    p.pose.position.x += offset_x
    p.pose.position.z += offset_z
    #listener.waitForTransform("/camera_rgb_optical_frame", "/map", rospy.Time.now(), rospy.Duration(10.0))
    tp = listener.transformPose("map", p)
    tp.pose.orientation.x = ox
    tp.pose.orientation.y = oy
    tp.pose.orientation.z = oz
    tp.pose.orientation.w = ow
    #if tf2.frameExists("/camera_rgb_optical_frame") and tf2.frameExists("/map"):
    #    t = tf2.getLatestCommonTime("/camera_rgb_optical_frame", "/map")
    #    position, quaternion = tf2.lookupTransform("/camera_rgb_optical_frame", "/map", t)
    #    print position, quaternion
    #return tf2.transformPose("/map", p)
    return tp

def callbackQR(data):
    global qrCodes
    qrCodes.add(data.data)

def callback2(data):
    global currentPosition
    currentPosition = data

def callback(data):
#    global pointSet
#    global pointFirst
#    if not pointSet:
#        pointFirst = data
#        pointSet = True
#    else:
#        data = pointFirst
#    data.pose.position.z -= 0.5

    global qrCodes
    moves = []
    for arg in sys.argv[1:]:
        moves.append(transformFromCameraToMap(data, *points[arg]))
    while len(qrCodes) < 2:
        for m in moves:
            move(m)
    
    activateFerns(qrCodes)
    #TODO start moving


rospy.init_node('psywerx_navigate')
client = SimpleActionClient('move_base', MoveBaseAction)
client.wait_for_server()
pointSet = False
pointFirst = PoseStamped()

#premakni se 1.5m naprej
m = PoseStamped()
m.pose.position.x = 2.0
m.pose.orientation.w = 1.0
m.header.frame_id = "base_link"
move(m, "base_link")

listener = tf.TransformListener()
rospy.sleep(3.0)
rospy.Subscriber("/psywerx_pointcloud/outputPoint", PoseStamped, callback)
rospy.Subscriber("/amcl_pose", PoseWithCovarianceStamped, callback2)
rospy.Subscriber('markers', Marker, callbackQR)
rospy.Subscriber("/get_status", ModelStatus, callbackFerns)
pub = rospy.Publisher('/set_status', ModelStatus)

rospy.spin()
